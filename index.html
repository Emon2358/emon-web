<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>Web VJ - Junk Crusher</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
        body {
            font-family: 'Consolas', 'Monaco', monospace;
            background-color: #111;
            color: #0f0;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            margin: 0;
            padding: 1em;
            overflow: hidden;
            height: 100vh;
        }

        h1 {
            color: #f0f;
            text-shadow: 0 0 5px #f0f, 0 0 10px #f0f;
            margin-bottom: 0.5em;
            text-align: center;
        }

        #video-container {
            position: relative;
            background: #000;
            border: 2px solid #0f0;
            box-shadow: 0 0 15px #0f0 inset;
            /* å›ºå®šã‚µã‚¤ã‚º */
            width: 640px;
            height: 480px;
        }

        canvas {
            width: 100%;
            height: 100%;
            display: block;
        }

        /* ã‚½ãƒ¼ã‚¹ã¨ãªã‚‹videoè¦ç´ ã¯éè¡¨ç¤º */
        video {
            display: none;
        }

        #controls {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 15px;
            margin-top: 20px;
            padding: 15px;
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid #0a0;
            max-width: 90%;
        }

        .input-group, .slider-group {
            display: flex;
            flex-direction: column;
            align-items: flex-start;
            width: 250px;
            min-width: 150px;
            flex-grow: 1;
        }

        label {
            font-size: 0.9em;
            margin-bottom: 5px;
            color: #0f0;
        }

        input[type="range"] {
            -webkit-appearance: none;
            width: 100%;
            height: 8px;
            background: #333;
            outline: none;
            border: 1px solid #0f0;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            background: #f0f;
            border: 2px solid #0f0;
            cursor: pointer;
            box-shadow: 0 0 10px #f0f;
        }
        
        input[type="file"] {
            background: #333;
            border: 1px solid #0f0;
            color: #f0f;
            padding: 5px;
            width: calc(100% - 12px);
            margin-bottom: 5px;
        }

        input[type="file"]::file-selector-button {
            background: #000;
            color: #0f0;
            border: 1px solid #0f0;
            padding: 5px 10px;
            cursor: pointer;
        }

        button {
            background: #111;
            color: #f0f;
            border: 2px solid #f0f;
            padding: 10px 20px;
            font-size: 1em;
            font-family: inherit;
            cursor: pointer;
            text-shadow: 0 0 5px #f0f;
            transition: all 0.2s;
            margin-top: 10px;
        }

        button:hover {
            background: #f0f;
            color: #111;
            box-shadow: 0 0 15px #f0f;
        }
    </style>
</head>
<body>

    <h1>Web VJ - Junk Crusher ğŸ“¼</h1>

    <div id="video-container">
        <canvas id="outputCanvas" width="640" height="480"></canvas>
    </div>

    <div id="controls">
        <div class="input-group">
            <label for="fileInput">VIDEO FILES (è¤‡æ•°é¸æŠå¯)</label>
            <input type="file" id="fileInput" accept="video/*" multiple>
        </div>
        
        <div class="input-group">
            <label for="urlInput">VIDEO URL (å¤–éƒ¨URL)</label>
            <input type="text" id="urlInput" placeholder="CORSå¯¾å¿œURLã®ã¿">
            <button id="loadURL">URLã‚’èª­ã¿è¾¼ã‚€</button>
        </div>

        <div class="slider-group" style="width: 48%;">
            <label for="colorShift">CHROMA DELAY (è‰²ä¿¡å·é…å»¶)</label>
            <input type=range id="colorShift" min="0" max="100" value="0">
        </div>
        
        <div class="slider-group" style="width: 48%;">
            <label for="dataCrash">DATA CRASH (ãƒ‡ãƒ¼ã‚¿ç ´å£Š)</label>
            <input type=range id="dataCrash" min="0" max="100" value="0">
        </div>
    </div>

    <script>
        const canvas = document.getElementById('outputCanvas');
        // 2Dã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã‚’ä¸€åº¦ã ã‘å–å¾—
        const ctx = canvas.getContext('2d', { willReadFrequently: true });

        const fileInput = document.getElementById('fileInput');
        const urlInput = document.getElementById('urlInput');
        const loadURLButton = document.getElementById('loadURL');

        // ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«
        const colorSlider = document.getElementById('colorShift');
        const crashSlider = document.getElementById('dataCrash'); // è¿½åŠ 

        // ã‚­ãƒ£ãƒ³ãƒã‚¹ã‚µã‚¤ã‚º (å›ºå®š)
        const canvasWidth = canvas.width;
        const canvasHeight = canvas.height;

        let animationFrameId;
        
        // å‹•ä½œä¸­ã®ãƒ“ãƒ‡ã‚ªã‚½ãƒ¼ã‚¹ã‚’ç®¡ç†ã™ã‚‹é…åˆ—
        let activeSources = [];

        // 1. ãƒ­ãƒ¼ã‚«ãƒ«å‹•ç”»ãƒ•ã‚¡ã‚¤ãƒ«ã®èª­ã¿è¾¼ã¿ (è¤‡æ•°å¯¾å¿œ)
        fileInput.addEventListener('change', (event) => {
            const files = event.target.files;
            if (!files) return;

            for (const file of files) {
                const objectURL = URL.createObjectURL(file);
                const fileVideo = document.createElement('video');
                fileVideo.src = objectURL;
                fileVideo.autoplay = true;
                fileVideo.playsinline = true;
                fileVideo.loop = true;
                fileVideo.muted = true;

                fileVideo.play().catch(e => console.error("Video file play error:", e));
                
                activeSources.push(fileVideo);
            }
            
            // æç”»ãƒ«ãƒ¼ãƒ—ã‚’é–‹å§‹
            if (files.length > 0 && !animationFrameId) {
                animationFrameId = requestAnimationFrame(processFrame);
            }
        });

        // 2. å‹•ç”»URLã®èª­ã¿è¾¼ã¿
        loadURLButton.addEventListener('click', () => {
            const url = urlInput.value.trim();
            if (url) {
                const urlVideo = document.createElement('video');
                urlVideo.src = url;
                urlVideo.autoplay = true;
                urlVideo.playsinline = true;
                urlVideo.loop = true;
                urlVideo.muted = true;
                urlVideo.crossOrigin = "anonymous"; // CORSå¯¾å¿œ

                urlVideo.play().catch(e => {
                    console.error("Video URL play error:", e);
                    alert("URLå‹•ç”»ã®èª­ã¿è¾¼ã¿ãƒ»å†ç”Ÿã«å¤±æ•—ã—ã¾ã—ãŸã€‚CORSã®å•é¡ŒãŒãªã„ã‹ç¢ºèªã—ã¦ãã ã•ã„ã€‚");
                });
                
                activeSources.push(urlVideo);

                // æç”»ãƒ«ãƒ¼ãƒ—ã‚’é–‹å§‹
                if (!animationFrameId) {
                    animationFrameId = requestAnimationFrame(processFrame);
                }
            }
        });

        // 3. æ¯ãƒ•ãƒ¬ãƒ¼ãƒ ã®å‡¦ç†
        function processFrame() {
            // ã‚½ãƒ¼ã‚¹ãŒãªã‘ã‚Œã°åœæ­¢
            if (activeSources.length === 0) {
                 animationFrameId = null;
                 ctx.fillStyle = '#000';
                 ctx.fillRect(0, 0, canvasWidth, canvasHeight);
                 animationFrameId = requestAnimationFrame(processFrame);
                 return;
            }
            
            // A. ã‚­ãƒ£ãƒ³ãƒã‚¹ã‚’ã‚¯ãƒªã‚¢ (ã‚¢ã‚¹ãƒšã‚¯ãƒˆæ¯”ç¶­æŒã®ãŸã‚)
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvasWidth, canvasHeight);

            // B. è¤‡æ•°ã®ã‚½ãƒ¼ã‚¹ã‚’ãƒªã‚µã‚¤ã‚ºã—ã¦é‡ã­ã¦æç”»
            for (let i = 0; i < activeSources.length; i++) {
                const source = activeSources[i];
                if (source && !source.paused && !source.ended && source.videoWidth > 0) {
                    
                    // ã‚¢ã‚¹ãƒšã‚¯ãƒˆæ¯”ã‚’ç¶­æŒã—ã¦ãƒªã‚µã‚¤ã‚º (Contain)
                    const videoWidth = source.videoWidth;
                    const videoHeight = source.videoHeight;
                    const ratio = Math.min(canvasWidth / videoWidth, canvasHeight / videoHeight);
                    const newWidth = videoWidth * ratio;
                    const newHeight = videoHeight * ratio;
                    
                    // ã‚­ãƒ£ãƒ³ãƒã‚¹ã®ä¸­å¤®ã«é…ç½®
                    const x = (canvasWidth - newWidth) / 2;
                    const y = (canvasHeight - newHeight) / 2;

                    ctx.drawImage(source, x, y, newWidth, newHeight);
                }
            }

            // C. ãƒ”ã‚¯ã‚»ãƒ«ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—
            let imageData;
            try {
                // imageDataã¯ã‚­ãƒ£ãƒ³ãƒã‚¹å…¨ä½“ã‹ã‚‰å–å¾— (640x480)
                imageData = ctx.getImageData(0, 0, canvasWidth, canvasHeight);
            } catch (e) {
                console.error("ImageDataã®å–å¾—ã«å¤±æ•— (CORSãªã©):", e);
                animationFrameId = requestAnimationFrame(processFrame);
                return;
            }

            const data = imageData.data;
            const width = canvasWidth;

            // D. ã‚°ãƒªãƒƒãƒã‚¨ãƒ•ã‚§ã‚¯ãƒˆã®é©ç”¨
            const colorAmount = parseInt(colorSlider.value, 10);
            const crashAmount = parseInt(crashSlider.value, 10); // è¿½åŠ 

            // 1. DATA CRASH (ãƒ‡ãƒ¼ã‚¿ç ´å£Š) - æ¿€ã—ã„ãƒ‡ã‚¸ã‚¿ãƒ«ç ´å£Š
            if (crashAmount > 0) {
                applyDataCrash(data, width, crashAmount);
            }

            // 2. CHROMA DELAY (è‰²ä¿¡å·é…å»¶) - ã‚¢ãƒŠãƒ­ã‚°åŠ£åŒ–
            if (colorAmount > 0) {
                applyChromaDelay(data, width, colorAmount);
            }

            // E. å‡¦ç†å¾Œã®ãƒ‡ãƒ¼ã‚¿ã‚’canvasã«æ›¸ãæˆ»ã™
            ctx.putImageData(imageData, 0, 0);

            // F. æ¬¡ã®ãƒ•ãƒ¬ãƒ¼ãƒ ã‚’è¦æ±‚
            animationFrameId = requestAnimationFrame(processFrame);
        }
        
        // æœ€åˆã®ãƒ•ãƒ¬ãƒ¼ãƒ å‘¼ã³å‡ºã—
        animationFrameId = requestAnimationFrame(processFrame);


        // 5. è‰²ä¿¡å·é…å»¶ (Chroma Delay) ã‚¨ãƒ•ã‚§ã‚¯ãƒˆ
        function applyChromaDelay(data, width, amount) {
            const shift = Math.floor(amount / 5); // 0-20 ãƒ”ã‚¯ã‚»ãƒ«
            if (shift === 0) return;

            const Y_R = 0.299, Y_G = 0.587, Y_B = 0.114;
            const V_R = 1.140, U_G = -0.395, V_G = -0.581, U_B = 2.032;

            let lineChroma = new Float32Array(width * 2); 
            let x_idx = 0;

            for (let i = 0; i < data.length; i += 4) {
                const r = data[i];
                const g = data[i + 1];
                const b = data[i + 2];
                
                const y_curr = Y_R * r + Y_G * g + Y_B * b;
                const u_curr = 0.492 * (b - y_curr);
                const v_curr = 0.877 * (r - y_curr);
                
                lineChroma[x_idx * 2] = u_curr;
                lineChroma[x_idx * 2 + 1] = v_curr;

                let chroma_idx = x_idx - shift;
                if (chroma_idx < 0) chroma_idx = 0; 

                const u_delay = lineChroma[chroma_idx * 2];
                const v_delay = lineChroma[chroma_idx * 2 + 1];

                let new_r = y_curr + V_R * v_delay;
                let new_g = y_curr + U_G * u_delay + V_G * v_delay;
                let new_b = y_curr + U_B * u_delay;

                data[i]     = Math.max(0, Math.min(255, new_r));
                data[i + 1] = Math.max(0, Math.min(255, new_g));
                data[i + 2] = Math.max(0, Math.min(255, new_b));

                x_idx++;
                if (x_idx === width) {
                    x_idx = 0; 
                    lineChroma.fill(0);
                }
            }
        }

        // 6. ãƒ‡ãƒ¼ã‚¿ç ´å£Š (Data Crash) ã‚¨ãƒ•ã‚§ã‚¯ãƒˆ
        function applyDataCrash(data, width, amount) {
            // amount (0-100) ã«å¿œã˜ã¦ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‚’æ±ºå®š
            // ä»¥å‰ã‚ˆã‚Šæ¿€ã—ãã™ã‚‹ãŸã‚ã«ä¿‚æ•°ã‚’èª¿æ•´
            const glitchProbability = amount / 250; // ç™ºç”Ÿç¢ºç‡ (æœ€å¤§40%)
            const maxBlockSize = Math.floor((data.length) * (amount / 400)); // ãƒ–ãƒ­ãƒƒã‚¯ã‚µã‚¤ã‚º (æœ€å¤§ 1/4)
            const maxOffset = Math.floor((data.length) * (amount / 300)); // ã‚ªãƒ•ã‚»ãƒƒãƒˆ (æœ€å¤§ 1/3)

            for (let i = 0; i < data.length; i += 4) {
                if (Math.random() < glitchProbability) {
                    // ç ´å£Šã™ã‚‹ãƒ–ãƒ­ãƒƒã‚¯ã‚µã‚¤ã‚º
                    const blockSize = Math.floor(Math.random() * maxBlockSize);
                    
                    // ã‚³ãƒ”ãƒ¼å…ƒã®ã‚ªãƒ•ã‚»ãƒƒãƒˆ
                    let offset = Math.floor(Math.random() * maxOffset) - (maxOffset / 2);
                    offset = offset - (offset % 4); // 4ãƒã‚¤ãƒˆ(RGBA)å˜ä½ã«æƒãˆã‚‹

                    if (i + offset >= 0 && i + offset < data.length) {
                         const sourceIndex = i + offset;
                         // ãƒ–ãƒ­ãƒƒã‚¯ã‚’ä¸¸ã”ã¨ã‚³ãƒ”ãƒ¼ (Buffer.copy ã®ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³)
                         for (let j = 0; j < blockSize && i + j < data.length && sourceIndex + j < data.length; j += 4) {
                            data[i + j]     = data[sourceIndex + j];
                            data[i + j + 1] = data[sourceIndex + j + 1];
                            data[i + j + 2] = data[sourceIndex + j + 2];
                         }
                         i += blockSize; // å‡¦ç†ã—ãŸåˆ†ã ã‘ã‚¸ãƒ£ãƒ³ãƒ—
                    }
                }
            }
        }
    </script>

</body>
</html>
