<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>Web VJ - Junk Crusher</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
        body {
            font-family: 'Consolas', 'Monaco', monospace;
            background-color: #111;
            color: #0f0;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            margin: 0;
            padding: 1em;
            overflow: hidden;
            height: 100vh;
        }

        h1 {
            color: #f0f;
            text-shadow: 0 0 5px #f0f, 0 0 10px #f0f;
            margin-bottom: 0.5em;
            text-align: center;
        }

        #video-container {
            position: relative;
            background: #000;
            border: 2px solid #0f0;
            box-shadow: 0 0 15px #0f0 inset;
            /* 固定サイズ */
            width: 640px;
            height: 480px;
        }

        canvas {
            width: 100%;
            height: 100%;
            display: block;
        }

        /* ソースとなるvideo要素は非表示 */
        video {
            display: none;
        }

        #controls {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 15px;
            margin-top: 20px;
            padding: 15px;
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid #0a0;
            max-width: 90%;
        }

        .input-group, .slider-group {
            display: flex;
            flex-direction: column;
            align-items: flex-start;
            width: 250px;
            min-width: 150px;
            flex-grow: 1;
        }

        label {
            font-size: 0.9em;
            margin-bottom: 5px;
            color: #0f0;
        }

        input[type="range"] {
            -webkit-appearance: none;
            width: 100%;
            height: 8px;
            background: #333;
            outline: none;
            border: 1px solid #0f0;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            background: #f0f;
            border: 2px solid #0f0;
            cursor: pointer;
            box-shadow: 0 0 10px #f0f;
        }
        
        input[type="file"] {
            background: #333;
            border: 1px solid #0f0;
            color: #f0f;
            padding: 5px;
            width: calc(100% - 12px);
            margin-bottom: 5px;
        }

        input[type="file"]::file-selector-button {
            background: #000;
            color: #0f0;
            border: 1px solid #0f0;
            padding: 5px 10px;
            cursor: pointer;
        }

        button {
            background: #111;
            color: #f0f;
            border: 2px solid #f0f;
            padding: 10px 20px;
            font-size: 1em;
            font-family: inherit;
            cursor: pointer;
            text-shadow: 0 0 5px #f0f;
            transition: all 0.2s;
            margin-top: 10px;
        }

        button:hover {
            background: #f0f;
            color: #111;
            box-shadow: 0 0 15px #f0f;
        }
    </style>
</head>
<body>

    <h1>Web VJ - Junk Crusher 📼</h1>

    <div id="video-container">
        <canvas id="outputCanvas" width="640" height="480"></canvas>
    </div>

    <div id="controls">
        <div class="input-group">
            <label for="fileInput">VIDEO FILES (複数選択可)</label>
            <input type="file" id="fileInput" accept="video/*" multiple>
        </div>
        
        <div class="input-group">
            <label for="urlInput">VIDEO URL (外部URL)</label>
            <input type="text" id="urlInput" placeholder="CORS対応URLのみ">
            <button id="loadURL">URLを読み込む</button>
        </div>

        <div class="slider-group" style="width: 48%;">
            <label for="colorShift">CHROMA DELAY (色信号遅延)</label>
            <input type=range id="colorShift" min="0" max="100" value="0">
        </div>
        
        <div class="slider-group" style="width: 48%;">
            <label for="dataCrash">DATA CRASH (データ破壊)</label>
            <input type=range id="dataCrash" min="0" max="100" value="0">
        </div>
    </div>

    <script>
        const canvas = document.getElementById('outputCanvas');
        // 2Dコンテキストを一度だけ取得
        const ctx = canvas.getContext('2d', { willReadFrequently: true });

        const fileInput = document.getElementById('fileInput');
        const urlInput = document.getElementById('urlInput');
        const loadURLButton = document.getElementById('loadURL');

        // コントロール
        const colorSlider = document.getElementById('colorShift');
        const crashSlider = document.getElementById('dataCrash'); // 追加

        // キャンバスサイズ (固定)
        const canvasWidth = canvas.width;
        const canvasHeight = canvas.height;

        let animationFrameId;
        
        // 動作中のビデオソースを管理する配列
        let activeSources = [];

        // 1. ローカル動画ファイルの読み込み (複数対応)
        fileInput.addEventListener('change', (event) => {
            const files = event.target.files;
            if (!files) return;

            for (const file of files) {
                const objectURL = URL.createObjectURL(file);
                const fileVideo = document.createElement('video');
                fileVideo.src = objectURL;
                fileVideo.autoplay = true;
                fileVideo.playsinline = true;
                fileVideo.loop = true;
                fileVideo.muted = true;

                fileVideo.play().catch(e => console.error("Video file play error:", e));
                
                activeSources.push(fileVideo);
            }
            
            // 描画ループを開始
            if (files.length > 0 && !animationFrameId) {
                animationFrameId = requestAnimationFrame(processFrame);
            }
        });

        // 2. 動画URLの読み込み
        loadURLButton.addEventListener('click', () => {
            const url = urlInput.value.trim();
            if (url) {
                const urlVideo = document.createElement('video');
                urlVideo.src = url;
                urlVideo.autoplay = true;
                urlVideo.playsinline = true;
                urlVideo.loop = true;
                urlVideo.muted = true;
                urlVideo.crossOrigin = "anonymous"; // CORS対応

                urlVideo.play().catch(e => {
                    console.error("Video URL play error:", e);
                    alert("URL動画の読み込み・再生に失敗しました。CORSの問題がないか確認してください。");
                });
                
                activeSources.push(urlVideo);

                // 描画ループを開始
                if (!animationFrameId) {
                    animationFrameId = requestAnimationFrame(processFrame);
                }
            }
        });

        // 3. 毎フレームの処理
        function processFrame() {
            // ソースがなければ停止
            if (activeSources.length === 0) {
                 animationFrameId = null;
                 ctx.fillStyle = '#000';
                 ctx.fillRect(0, 0, canvasWidth, canvasHeight);
                 animationFrameId = requestAnimationFrame(processFrame);
                 return;
            }
            
            // A. キャンバスをクリア (アスペクト比維持のため)
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvasWidth, canvasHeight);

            // B. 複数のソースをリサイズして重ねて描画
            for (let i = 0; i < activeSources.length; i++) {
                const source = activeSources[i];
                if (source && !source.paused && !source.ended && source.videoWidth > 0) {
                    
                    // アスペクト比を維持してリサイズ (Contain)
                    const videoWidth = source.videoWidth;
                    const videoHeight = source.videoHeight;
                    const ratio = Math.min(canvasWidth / videoWidth, canvasHeight / videoHeight);
                    const newWidth = videoWidth * ratio;
                    const newHeight = videoHeight * ratio;
                    
                    // キャンバスの中央に配置
                    const x = (canvasWidth - newWidth) / 2;
                    const y = (canvasHeight - newHeight) / 2;

                    ctx.drawImage(source, x, y, newWidth, newHeight);
                }
            }

            // C. ピクセルデータを取得
            let imageData;
            try {
                // imageDataはキャンバス全体から取得 (640x480)
                imageData = ctx.getImageData(0, 0, canvasWidth, canvasHeight);
            } catch (e) {
                console.error("ImageDataの取得に失敗 (CORSなど):", e);
                animationFrameId = requestAnimationFrame(processFrame);
                return;
            }

            const data = imageData.data;
            const width = canvasWidth;

            // D. グリッチエフェクトの適用
            const colorAmount = parseInt(colorSlider.value, 10);
            const crashAmount = parseInt(crashSlider.value, 10); // 追加

            // 1. DATA CRASH (データ破壊) - 激しいデジタル破壊
            if (crashAmount > 0) {
                applyDataCrash(data, width, crashAmount);
            }

            // 2. CHROMA DELAY (色信号遅延) - アナログ劣化
            if (colorAmount > 0) {
                applyChromaDelay(data, width, colorAmount);
            }

            // E. 処理後のデータをcanvasに書き戻す
            ctx.putImageData(imageData, 0, 0);

            // F. 次のフレームを要求
            animationFrameId = requestAnimationFrame(processFrame);
        }
        
        // 最初のフレーム呼び出し
        animationFrameId = requestAnimationFrame(processFrame);


        // 5. 色信号遅延 (Chroma Delay) エフェクト
        function applyChromaDelay(data, width, amount) {
            const shift = Math.floor(amount / 5); // 0-20 ピクセル
            if (shift === 0) return;

            const Y_R = 0.299, Y_G = 0.587, Y_B = 0.114;
            const V_R = 1.140, U_G = -0.395, V_G = -0.581, U_B = 2.032;

            let lineChroma = new Float32Array(width * 2); 
            let x_idx = 0;

            for (let i = 0; i < data.length; i += 4) {
                const r = data[i];
                const g = data[i + 1];
                const b = data[i + 2];
                
                const y_curr = Y_R * r + Y_G * g + Y_B * b;
                const u_curr = 0.492 * (b - y_curr);
                const v_curr = 0.877 * (r - y_curr);
                
                lineChroma[x_idx * 2] = u_curr;
                lineChroma[x_idx * 2 + 1] = v_curr;

                let chroma_idx = x_idx - shift;
                if (chroma_idx < 0) chroma_idx = 0; 

                const u_delay = lineChroma[chroma_idx * 2];
                const v_delay = lineChroma[chroma_idx * 2 + 1];

                let new_r = y_curr + V_R * v_delay;
                let new_g = y_curr + U_G * u_delay + V_G * v_delay;
                let new_b = y_curr + U_B * u_delay;

                data[i]     = Math.max(0, Math.min(255, new_r));
                data[i + 1] = Math.max(0, Math.min(255, new_g));
                data[i + 2] = Math.max(0, Math.min(255, new_b));

                x_idx++;
                if (x_idx === width) {
                    x_idx = 0; 
                    lineChroma.fill(0);
                }
            }
        }

        // 6. データ破壊 (Data Crash) エフェクト
        function applyDataCrash(data, width, amount) {
            // amount (0-100) に応じてパラメータを決定
            // 以前より激しくするために係数を調整
            const glitchProbability = amount / 250; // 発生確率 (最大40%)
            const maxBlockSize = Math.floor((data.length) * (amount / 400)); // ブロックサイズ (最大 1/4)
            const maxOffset = Math.floor((data.length) * (amount / 300)); // オフセット (最大 1/3)

            for (let i = 0; i < data.length; i += 4) {
                if (Math.random() < glitchProbability) {
                    // 破壊するブロックサイズ
                    const blockSize = Math.floor(Math.random() * maxBlockSize);
                    
                    // コピー元のオフセット
                    let offset = Math.floor(Math.random() * maxOffset) - (maxOffset / 2);
                    offset = offset - (offset % 4); // 4バイト(RGBA)単位に揃える

                    if (i + offset >= 0 && i + offset < data.length) {
                         const sourceIndex = i + offset;
                         // ブロックを丸ごとコピー (Buffer.copy のシミュレーション)
                         for (let j = 0; j < blockSize && i + j < data.length && sourceIndex + j < data.length; j += 4) {
                            data[i + j]     = data[sourceIndex + j];
                            data[i + j + 1] = data[sourceIndex + j + 1];
                            data[i + j + 2] = data[sourceIndex + j + 2];
                         }
                         i += blockSize; // 処理した分だけジャンプ
                    }
                }
            }
        }
    </script>

</body>
</html>
