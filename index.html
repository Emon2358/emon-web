<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>Web VJ - Chroma Delay Simulator</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
        body {
            font-family: 'Consolas', 'Monaco', monospace;
            background-color: #111;
            color: #0f0;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            margin: 0;
            padding: 1em;
            overflow: hidden;
            height: 100vh;
        }

        h1 {
            color: #f0f;
            text-shadow: 0 0 5px #f0f, 0 0 10px #f0f;
            margin-bottom: 0.5em;
            text-align: center;
        }

        #video-container {
            position: relative;
            background: #000;
            border: 2px solid #0f0;
            box-shadow: 0 0 15px #0f0 inset;
            /* 固定サイズ */
            width: 640px;
            height: 480px;
        }

        canvas {
            width: 100%;
            height: 100%;
            display: block;
        }

        /* ソースとなるvideo要素は非表示 */
        video {
            display: none;
        }

        #controls {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 15px;
            margin-top: 20px;
            padding: 15px;
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid #0a0;
            max-width: 90%;
        }

        .input-group, .slider-group {
            display: flex;
            flex-direction: column;
            align-items: flex-start;
            width: 250px;
            min-width: 150px;
            flex-grow: 1;
        }

        label {
            font-size: 0.9em;
            margin-bottom: 5px;
            color: #0f0;
        }

        input[type="range"] {
            -webkit-appearance: none;
            width: 100%;
            height: 8px;
            background: #333;
            outline: none;
            border: 1px solid #0f0;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            background: #f0f;
            border: 2px solid #0f0;
            cursor: pointer;
            box-shadow: 0 0 10px #f0f;
        }
        
        input[type="file"] {
            background: #333;
            border: 1px solid #0f0;
            color: #f0f;
            padding: 5px;
            width: calc(100% - 12px);
            margin-bottom: 5px;
        }

        input[type="file"]::file-selector-button {
            background: #000;
            color: #0f0;
            border: 1px solid #0f0;
            padding: 5px 10px;
            cursor: pointer;
        }

        button {
            background: #111;
            color: #f0f;
            border: 2px solid #f0f;
            padding: 10px 20px;
            font-size: 1em;
            font-family: inherit;
            cursor: pointer;
            text-shadow: 0 0 5px #f0f;
            transition: all 0.2s;
            margin-top: 10px;
        }

        button:hover {
            background: #f0f;
            color: #111;
            box-shadow: 0 0 15px #f0f;
        }
    </style>
</head>
<body>

    <h1>Web VJ - Chroma Delay Simulator 📼</h1>

    <div id="video-container">
        <canvas id="outputCanvas" width="640" height="480"></canvas>
    </div>

    <div id="controls">
        <div class="input-group">
            <button id="startCam">CAM START</button>
        </div>

        <div class="input-group">
            <label for="fileInput">VIDEO FILES (複数選択可)</label>
            <input type="file" id="fileInput" accept="video/*" multiple>
        </div>
        
        <div class="input-group">
            <label for="urlInput">VIDEO URL (外部URL)</label>
            <input type="text" id="urlInput" placeholder="CORS対応URLのみ">
            <button id="loadURL">URLを読み込む</button>
        </div>

        <div class="slider-group" style="width: 100%;">
            <label for="colorShift">CHROMA DELAY (色信号遅延)</label>
            <input type=range id="colorShift" min="0" max="100" value="0">
        </div>
    </div>

    <script>
        const canvas = document.getElementById('outputCanvas');
        // 2Dコンテキストを一度だけ取得
        const ctx = canvas.getContext('2d', { willReadFrequently: true });

        const startCamButton = document.getElementById('startCam');
        const fileInput = document.getElementById('fileInput');
        const urlInput = document.getElementById('urlInput');
        const loadURLButton = document.getElementById('loadURL');

        // コントロール
        const colorSlider = document.getElementById('colorShift');

        // キャンバスサイズ (固定)
        const canvasWidth = canvas.width;
        const canvasHeight = canvas.height;

        let animationFrameId;
        
        // 動作中のビデオソースを管理する配列
        let activeSources = [];

        // 1. Webカメラの起動
        async function startWebcam() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({
                    video: { width: canvasWidth, height: canvasHeight },
                    audio: false
                });
                const webcamVideo = document.createElement('video');
                webcamVideo.srcObject = stream;
                webcamVideo.autoplay = true;
                webcamVideo.playsinline = true;
                webcamVideo.muted = true;
                
                await webcamVideo.play();
                
                startCamButton.textContent = "CAM RUNNING...";
                startCamButton.disabled = true;
                
                activeSources.push(webcamVideo);

                // 描画ループを開始
                if (!animationFrameId) {
                    animationFrameId = requestAnimationFrame(processFrame);
                }

            } catch (err) {
                console.error("カメラの起動に失敗しました:", err);
                alert("カメラにアクセスできません。ブラウザの許可設定を確認してください。");
            }
        }
        startCamButton.addEventListener('click', startWebcam);

        // 2. ローカル動画ファイルの読み込み (複数対応)
        fileInput.addEventListener('change', (event) => {
            const files = event.target.files;
            if (!files) return;

            for (const file of files) {
                const objectURL = URL.createObjectURL(file);
                const fileVideo = document.createElement('video');
                fileVideo.src = objectURL;
                fileVideo.autoplay = true;
                fileVideo.playsinline = true;
                fileVideo.loop = true;
                fileVideo.muted = true;

                fileVideo.play().catch(e => console.error("Video file play error:", e));
                
                activeSources.push(fileVideo);
            }
            
            // 描画ループを開始
            if (files.length > 0 && !animationFrameId) {
                animationFrameId = requestAnimationFrame(processFrame);
            }
        });

        // 3. 動画URLの読み込み
        loadURLButton.addEventListener('click', () => {
            const url = urlInput.value.trim();
            if (url) {
                const urlVideo = document.createElement('video');
                urlVideo.src = url;
                urlVideo.autoplay = true;
                urlVideo.playsinline = true;
                urlVideo.loop = true;
                urlVideo.muted = true;
                urlVideo.crossOrigin = "anonymous"; // CORS対応

                urlVideo.play().catch(e => {
                    console.error("Video URL play error:", e);
                    alert("URL動画の読み込み・再生に失敗しました。CORSの問題がないか確認してください。");
                });
                
                activeSources.push(urlVideo);

                // 描画ループを開始
                if (!animationFrameId) {
                    animationFrameId = requestAnimationFrame(processFrame);
                }
            }
        });

        // 4. 毎フレームの処理
        function processFrame() {
            // ソースがなければ停止
            if (activeSources.length === 0) {
                 animationFrameId = null;
                 return;
            }
            
            // A. キャンバスをクリア (アスペクト比維持のため)
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvasWidth, canvasHeight);

            let allSourcesReady = true;

            // B. 複数のソースをリサイズして重ねて描画
            for (let i = 0; i < activeSources.length; i++) {
                const source = activeSources[i];
                if (source && !source.paused && !source.ended && source.videoWidth > 0) {
                    
                    // アスペクト比を維持してリサイズ (Contain)
                    const videoWidth = source.videoWidth;
                    const videoHeight = source.videoHeight;
                    const ratio = Math.min(canvasWidth / videoWidth, canvasHeight / videoHeight);
                    const newWidth = videoWidth * ratio;
                    const newHeight = videoHeight * ratio;
                    
                    // キャンバスの中央に配置
                    const x = (canvasWidth - newWidth) / 2;
                    const y = (canvasHeight - newHeight) / 2;

                    ctx.drawImage(source, x, y, newWidth, newHeight);
                } else if (!source || source.videoWidth === 0) {
                    allSourcesReady = false; // まだロード中
                }
            }

            // C. ピクセルデータを取得
            let imageData;
            try {
                // imageDataはキャンバス全体から取得 (640x480)
                imageData = ctx.getImageData(0, 0, canvasWidth, canvasHeight);
            } catch (e) {
                console.error("ImageDataの取得に失敗 (CORSなど):", e);
                // URL動画の場合、クロスオリジン制約によりImageDataの取得ができないことがある
                animationFrameId = requestAnimationFrame(processFrame);
                return;
            }

            // D. グリッチエフェクト（色信号遅延）の適用
            const colorAmount = parseInt(colorSlider.value, 10);
            if (colorAmount > 0) {
                applyChromaDelay(imageData.data, canvasWidth, colorAmount);
            }

            // E. 処理後のデータをcanvasに書き戻す
            ctx.putImageData(imageData, 0, 0);

            // F. 次のフレームを要求
            animationFrameId = requestAnimationFrame(processFrame);
        }

        // 5. 色信号遅延 (Chroma Delay) エフェクト
        // 輝度(Y)はその場に留め、色情報(U, V)を過去(左)のピクセルから持ってくる
        function applyChromaDelay(data, width, amount) {
            // amount (0-100) に応じて、色をズラすピクセル数 (shift) を決定
            const shift = Math.floor(amount / 5); // 0-20 ピクセル
            if (shift === 0) return;

            // 輝度計算の係数 (BT.601)
            const Y_R = 0.299;
            const Y_G = 0.587;
            const Y_B = 0.114;

            // YUV -> RGB 変換の係数 (概算)
            const V_R = 1.140;
            const U_G = -0.395;
            const V_G = -0.581;
            const U_B = 2.032;

            // 1行分の色情報(U, V)をバッファする
            let lineChroma = new Float32Array(width * 2); // [U0, V0, U1, V1, ...]
            let x_idx = 0;

            for (let i = 0; i < data.length; i += 4) {
                const r = data[i];
                const g = data[i + 1];
                const b = data[i + 2];
                
                // 1. 現在のピクセルの輝度(Y)を計算
                const y_curr = Y_R * r + Y_G * g + Y_B * b;

                // 2. 現在のピクセルの色差(U, V)を計算し、バッファに保存
                // YUVのU,V計算 (概算)
                const u_curr = 0.492 * (b - y_curr);
                const v_curr = 0.877 * (r - y_curr);
                
                lineChroma[x_idx * 2] = u_curr;
                lineChroma[x_idx * 2 + 1] = v_curr;

                // 3. 遅延させるインデックス(過去)を計算
                let chroma_idx = x_idx - shift;
                if (chroma_idx < 0) chroma_idx = 0; // 行の左端より前は参照しない

                // 4. 過去の色情報(U_delay, V_delay)を取得
                const u_delay = lineChroma[chroma_idx * 2];
                const v_delay = lineChroma[chroma_idx * 2 + 1];

                // 5. 「現在の輝度(Y_curr)」と「過去の色(U_delay, V_delay)」でRGBを再合成
                let new_r = y_curr + V_R * v_delay;
                let new_g = y_curr + U_G * u_delay + V_G * v_delay;
                let new_b = y_curr + U_B * u_delay;

                // 0-255 の範囲にクリップ
                data[i]     = Math.max(0, Math.min(255, new_r));
                data[i + 1] = Math.max(0, Math.min(255, new_g));
                data[i + 2] = Math.max(0, Math.min(255, new_b));
                // data[i + 3] (Alpha) は変更しない

                // 水平インデックス(x)を更新
                x_idx++;
                if (x_idx === width) {
                    x_idx = 0; // 次の行へ
                    // 行が変わったら色バッファをリセット（行をまたいで色がズレないように）
                    lineChroma.fill(0);
                }
            }
        }
    </script>

</body>
</html>
