<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>Web VJ - Glitch Crusher EX</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
        body {
            font-family: 'Consolas', 'Monaco', monospace;
            background-color: #111;
            color: #0f0;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            margin: 0;
            padding: 1em;
            overflow: hidden;
            height: 100vh;
        }

        h1 {
            color: #f0f;
            text-shadow: 0 0 5px #f0f, 0 0 10px #f0f;
            margin-bottom: 0.5em;
            text-align: center;
        }

        #video-container {
            position: relative;
            background: #000;
            border: 2px solid #0f0;
            box-shadow: 0 0 15px #0f0 inset;
            min-width: 640px;
            min-height: 480px;
        }

        canvas {
            width: 100%;
            height: 100%;
            display: block;
        }

        /* ã‚½ãƒ¼ã‚¹ã¨ãªã‚‹videoè¦ç´ ã¯éè¡¨ç¤ºã«ã™ã‚‹ */
        #webcam, #videoFile, #videoURL {
            display: none;
        }

        #controls {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 15px;
            margin-top: 20px;
            padding: 15px;
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid #0a0;
            max-width: 90%;
            overflow-x: auto;
        }

        .input-group, .slider-group {
            display: flex;
            flex-direction: column;
            align-items: flex-start; /* å·¦å¯„ã› */
            width: 250px;
            min-width: 150px;
            flex-grow: 1; /* æ¨ªå¹…ã„ã£ã±ã„ã«åºƒãŒã‚‹ */
        }

        label {
            font-size: 0.9em;
            margin-bottom: 5px;
            color: #0f0;
        }

        input[type="range"] {
            -webkit-appearance: none;
            width: 100%;
            height: 8px;
            background: #333;
            outline: none;
            border: 1px solid #0f0;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            background: #f0f;
            border: 2px solid #0f0;
            cursor: pointer;
            box-shadow: 0 0 10px #f0f;
        }

        input[type="range"]::-moz-range-thumb {
            width: 20px;
            height: 20px;
            background: #f0f;
            border: 2px solid #0f0;
            cursor: pointer;
            box-shadow: 0 0 10px #f0f;
        }

        input[type="file"], input[type="text"] {
            background: #333;
            border: 1px solid #0f0;
            color: #f0f;
            padding: 5px;
            width: calc(100% - 12px); /* paddingã¨borderåˆ†ã‚’å¼•ã */
            margin-bottom: 5px;
        }

        input[type="file"]::file-selector-button {
            background: #000;
            color: #0f0;
            border: 1px solid #0f0;
            padding: 5px 10px;
            cursor: pointer;
        }

        button {
            background: #111;
            color: #f0f;
            border: 2px solid #f0f;
            padding: 10px 20px;
            font-size: 1em;
            font-family: inherit;
            cursor: pointer;
            text-shadow: 0 0 5px #f0f;
            transition: all 0.2s;
            margin-top: 10px;
        }

        button:hover {
            background: #f0f;
            color: #111;
            box-shadow: 0 0 15px #f0f;
        }

        .separator {
            width: 100%;
            height: 1px;
            background: #0a0;
            margin: 10px 0;
        }
    </style>
</head>
<body>

    <h1>Web VJ - Glitch Crusher EX å»ƒæã‚¨ãƒ‡ã‚£ã‚·ãƒ§ãƒ³ ğŸ“¼</h1>

    <div id="video-container">
        <canvas id="outputCanvas"></canvas>
        <video id="webcam" autoplay playsinline muted></video>
        <video id="videoFile" autoplay playsinline loop muted></video>
        <video id="videoURL" autoplay playsinline loop muted crossorigin="anonymous"></video>
    </div>

    <div id="controls">
        <div class="input-group">
            <button id="startCam">CAM START</button>
        </div>

        <div class="input-group">
            <label for="fileInput">VIDEO FILE (ãƒ­ãƒ¼ã‚«ãƒ«ãƒ•ã‚¡ã‚¤ãƒ«)</label>
            <input type="file" id="fileInput" accept="video/*">
        </div>
        
        <div class="input-group">
            <label for="urlInput">VIDEO URL (å¤–éƒ¨URL)</label>
            <input type="text" id="urlInput" placeholder="ä¾‹: https://example.com/video.mp4">
            <button id="loadURL">URLã‚’èª­ã¿è¾¼ã‚€</button>
        </div>

        <div class="separator"></div>

        <div class="slider-group">
            <label for="glitchAmount">DATA CRASH (ãƒ‡ãƒ¼ã‚¿ç ´å£Š)</label>
            <input type=range id="glitchAmount" min="0" max="100" value="0">
        </div>
        <div class="slider-group">
            <label for="syncLoss">SYNC LOSS (åŒæœŸã‚ºãƒ¬)</label>
            <input type=range id="syncLoss" min="0" max="100" value="0">
        </div>
        <div class="slider-group">
            <label for="colorShift">COLOR BLEED (è‰²ã‚ºãƒ¬)</label>
            <input type=range id="colorShift" min="0" max="100" value="0">
        </div>
        <div class="slider-group">
            <label for="noiseAmount">STATIC NOISE (ç ‚åµãƒã‚¤ã‚º)</label>
            <input type=range id="noiseAmount" min="0" max="100" value="0">
        </div>
         <div class="slider-group">
            <label for="feedbackAmount">VIDEO FEEDBACK (æ˜ åƒãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯)</label>
            <input type=range id="feedbackAmount" min="0" max="100" value="0">
        </div>
        <div class="slider-group">
            <label for="opacityMix">SOURCE MIX (ã‚½ãƒ¼ã‚¹åˆæˆå¼·åº¦)</label>
            <input type=range id="opacityMix" min="0" max="100" value="50">
        </div>
    </div>

    <script>
        const webcamVideo = document.getElementById('webcam');
        const fileVideo = document.getElementById('videoFile');
        const urlVideo = document.getElementById('videoURL');
        const canvas = document.getElementById('outputCanvas');
        const ctx = canvas.getContext('2d', { willReadFrequently: true });

        const startCamButton = document.getElementById('startCam');
        const fileInput = document.getElementById('fileInput');
        const urlInput = document.getElementById('urlInput');
        const loadURLButton = document.getElementById('loadURL');

        // ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«
        const glitchSlider = document.getElementById('glitchAmount');
        const syncSlider = document.getElementById('syncLoss');
        const colorSlider = document.getElementById('colorShift');
        const noiseSlider = document.getElementById('noiseAmount');
        const feedbackSlider = document.getElementById('feedbackAmount');
        const opacityMixSlider = document.getElementById('opacityMix');

        let videoWidth = 640;
        let videoHeight = 480;
        let animationFrameId;

        // ç¾åœ¨ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãªã‚½ãƒ¼ã‚¹ã‚’è¿½è·¡
        let activeSources = [];

        // 1. Webã‚«ãƒ¡ãƒ©ã®èµ·å‹•
        async function startWebcam() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({
                    video: { width: videoWidth, height: videoHeight },
                    audio: false
                });
                webcamVideo.srcObject = stream;
                await webcamVideo.play();
                startCamButton.textContent = "CAM RUNNING...";
                startCamButton.disabled = true;
                
                // åˆå›ã®ã¿ã‚­ãƒ£ãƒ³ãƒã‚¹ã‚µã‚¤ã‚ºè¨­å®šã¨æç”»ãƒ«ãƒ¼ãƒ—é–‹å§‹
                if (!animationFrameId) {
                    webcamVideo.onloadedmetadata = () => {
                        videoWidth = webcamVideo.videoWidth;
                        videoHeight = webcamVideo.videoHeight;
                        canvas.width = videoWidth;
                        canvas.height = videoHeight;
                        if (!animationFrameId) { // é‡è¤‡é˜²æ­¢
                            animationFrameId = requestAnimationFrame(processFrame);
                        }
                    };
                }
                activeSources.push(webcamVideo);

            } catch (err) {
                console.error("ã‚«ãƒ¡ãƒ©ã®èµ·å‹•ã«å¤±æ•—ã—ã¾ã—ãŸ:", err);
                alert("ã‚«ãƒ¡ãƒ©ã«ã‚¢ã‚¯ã‚»ã‚¹ã§ãã¾ã›ã‚“ã€‚ãƒ–ãƒ©ã‚¦ã‚¶ã®è¨±å¯è¨­å®šã‚’ç¢ºèªã—ã¦ãã ã•ã„ã€‚");
            }
        }
        startCamButton.addEventListener('click', startWebcam);

        // 2. ãƒ­ãƒ¼ã‚«ãƒ«å‹•ç”»ãƒ•ã‚¡ã‚¤ãƒ«ã®èª­ã¿è¾¼ã¿
        fileInput.addEventListener('change', (event) => {
            const file = event.target.files[0];
            if (file) {
                const objectURL = URL.createObjectURL(file);
                fileVideo.src = objectURL;
                fileVideo.play().catch(e => console.error("Video file play error:", e));

                // åˆå›ã®ã¿ã‚­ãƒ£ãƒ³ãƒã‚¹ã‚µã‚¤ã‚ºè¨­å®šã¨æç”»ãƒ«ãƒ¼ãƒ—é–‹å§‹
                if (!animationFrameId) {
                    fileVideo.onloadedmetadata = () => {
                        videoWidth = fileVideo.videoWidth;
                        videoHeight = fileVideo.videoHeight;
                        canvas.width = videoWidth;
                        canvas.height = videoHeight;
                        if (!animationFrameId) { // é‡è¤‡é˜²æ­¢
                            animationFrameId = requestAnimationFrame(processFrame);
                        }
                    };
                }
                activeSources.push(fileVideo);
            }
        });

        // 3. å‹•ç”»URLã®èª­ã¿è¾¼ã¿
        loadURLButton.addEventListener('click', () => {
            const url = urlInput.value.trim();
            if (url) {
                urlVideo.src = url;
                urlVideo.play().catch(e => {
                    console.error("Video URL play error:", e);
                    alert("URLå‹•ç”»ã®èª­ã¿è¾¼ã¿ãƒ»å†ç”Ÿã«å¤±æ•—ã—ã¾ã—ãŸã€‚URLãŒæ­£ã—ã„ã‹ã€CORSã®å•é¡ŒãŒãªã„ã‹ç¢ºèªã—ã¦ãã ã•ã„ã€‚");
                });

                // åˆå›ã®ã¿ã‚­ãƒ£ãƒ³ãƒã‚¹ã‚µã‚¤ã‚ºè¨­å®šã¨æç”»ãƒ«ãƒ¼ãƒ—é–‹å§‹
                if (!animationFrameId) {
                    urlVideo.onloadedmetadata = () => {
                        videoWidth = urlVideo.videoWidth;
                        videoHeight = urlVideo.videoHeight;
                        canvas.width = videoWidth;
                        canvas.height = videoHeight;
                        if (!animationFrameId) { // é‡è¤‡é˜²æ­¢
                            animationFrameId = requestAnimationFrame(processFrame);
                        }
                    };
                }
                activeSources.push(urlVideo);
            }
        });

        // 4. æ¯ãƒ•ãƒ¬ãƒ¼ãƒ ã®å‡¦ç†
        function processFrame() {
            // ã‚½ãƒ¼ã‚¹ãŒãªã„å ´åˆã¯ä½•ã‚‚ã—ãªã„
            if (activeSources.length === 0) {
                 animationFrameId = requestAnimationFrame(processFrame);
                 return;
            }

            // ãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã‚’é©ç”¨ï¼ˆå‰ãƒ•ãƒ¬ãƒ¼ãƒ ã®ç”»åƒã‚’å°‘ã—æ®‹ã™ï¼‰
            const feedbackAmount = parseInt(feedbackSlider.value, 10);
            if (feedbackAmount > 0) {
                ctx.globalAlpha = 1 - (feedbackAmount / 150); // æ®‹åƒã®å¼·ã•
                ctx.drawImage(canvas, 0, 0, videoWidth, videoHeight);
                ctx.globalAlpha = 1;
            } else {
                ctx.clearRect(0, 0, videoWidth, videoHeight); // ãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯ãªã—ãªã‚‰ã‚¯ãƒªã‚¢
            }


            // è¤‡æ•°ã®ã‚½ãƒ¼ã‚¹ã‚’é‡ã­ã¦æç”»
            const opacityMix = parseInt(opacityMixSlider.value, 10) / 100;
            let firstSourceDrawn = false;

            for (let i = 0; i < activeSources.length; i++) {
                const source = activeSources[i];
                if (source && !source.paused && !source.ended) {
                    if (!firstSourceDrawn) {
                        ctx.drawImage(source, 0, 0, videoWidth, videoHeight);
                        firstSourceDrawn = true;
                    } else {
                        // 2ç•ªç›®ä»¥é™ã®ã‚½ãƒ¼ã‚¹ã¯é€æ˜åº¦ã‚’èª¿æ•´ã—ã¦é‡ã­ã‚‹
                        ctx.globalAlpha = opacityMix;
                        ctx.drawImage(source, 0, 0, videoWidth, videoHeight);
                        ctx.globalAlpha = 1; // å…ƒã«æˆ»ã™
                    }
                }
            }
            
            // å…¨ã¦ã®ã‚½ãƒ¼ã‚¹ãŒæ­¢ã¾ã£ã¦ã„ã‚‹å ´åˆ
            if (!firstSourceDrawn) {
                animationFrameId = requestAnimationFrame(processFrame);
                return;
            }


            // B. canvasã‹ã‚‰ãƒ”ã‚¯ã‚»ãƒ«ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—
            let imageData;
            try {
                imageData = ctx.getImageData(0, 0, videoWidth, videoHeight);
            } catch (e) {
                console.error("ImageDataã®å–å¾—ã«å¤±æ•— (CORSãªã©):", e);
                // URLå‹•ç”»ã®å ´åˆã€ã‚¯ãƒ­ã‚¹ã‚ªãƒªã‚¸ãƒ³åˆ¶ç´„ã«ã‚ˆã‚ŠImageDataã®å–å¾—ãŒã§ããªã„ã“ã¨ãŒã‚ã‚‹
                // ãã®å ´åˆã¯ã‚°ãƒªãƒƒãƒå‡¦ç†ã‚’ã‚¹ã‚­ãƒƒãƒ—ã—ã¦æ¬¡ã®ãƒ•ãƒ¬ãƒ¼ãƒ ã¸
                animationFrameId = requestAnimationFrame(processFrame);
                return;
            }

            const data = imageData.data; // ãƒ”ã‚¯ã‚»ãƒ«ãƒ‡ãƒ¼ã‚¿é…åˆ— (R, G, B, A, R, G, B, A, ...)

            // C. ã‚°ãƒªãƒƒãƒã‚¨ãƒ•ã‚§ã‚¯ãƒˆã®é©ç”¨
            applyGlitchEffects(data, videoWidth, videoHeight);

            // D. å‡¦ç†å¾Œã®ãƒ‡ãƒ¼ã‚¿ã‚’canvasã«æ›¸ãæˆ»ã™
            ctx.putImageData(imageData, 0, 0);

            // E. æ¬¡ã®ãƒ•ãƒ¬ãƒ¼ãƒ ã‚’è¦æ±‚
            animationFrameId = requestAnimationFrame(processFrame);
        }

        // 5. ã‚°ãƒªãƒƒãƒã‚¨ãƒ•ã‚§ã‚¯ãƒˆé–¢æ•°ç¾¤
        function applyGlitchEffects(data, width, height) {
            const glitchAmount = parseInt(glitchSlider.value, 10);
            const syncAmount = parseInt(syncSlider.value, 10);
            const colorAmount = parseInt(colorSlider.value, 10);
            const noiseAmount = parseInt(noiseSlider.value, 10);

            // ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ãŒ0ãªã‚‰å‡¦ç†ã‚’ã‚¹ã‚­ãƒƒãƒ— (ãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯ã¯åˆ¥ã§å‡¦ç†)
            if (glitchAmount === 0 && syncAmount === 0 && colorAmount === 0 && noiseAmount === 0) {
                return;
            }

            // --- DATA CRASH (ãƒ‡ãƒ¼ã‚¿ç ´å£Š) ---
            if (glitchAmount > 0) {
                const glitchProbability = glitchAmount / 500; // ç™ºç”Ÿç¢ºç‡ã‚’ä¸Šã’ã‚‹
                const maxBlockSize = Math.floor((height * width * 4) * (glitchAmount / 500)); // ãƒ–ãƒ­ãƒƒã‚¯ã‚µã‚¤ã‚ºã‚‚å¤§ãã
                const maxOffset = Math.floor((width * height * 4) * (glitchAmount / 400)); // ã‚ªãƒ•ã‚»ãƒƒãƒˆã‚‚å¤§ãã

                for (let i = 0; i < data.length; i += 4) {
                    if (Math.random() < glitchProbability) {
                        const blockSize = Math.floor(Math.random() * maxBlockSize);
                        let offset = Math.floor(Math.random() * maxOffset) - (maxOffset / 2);
                        offset = offset - (offset % 4); // 4ãƒã‚¤ãƒˆ(RGBA)å˜ä½ã«æƒãˆã‚‹

                        if (i + offset >= 0 && i + offset < data.length) {
                             const sourceIndex = i + offset;
                             for (let j = 0; j < blockSize && i + j < data.length && sourceIndex + j < data.length; j += 4) {
                                data[i + j]     = data[sourceIndex + j];
                                data[i + j + 1] = data[sourceIndex + j + 1];
                                data[i + j + 2] = data[sourceIndex + j + 2];
                             }
                             i += blockSize; // å‡¦ç†ã—ãŸåˆ†ã ã‘ã‚¸ãƒ£ãƒ³ãƒ—
                        }
                    }
                }
            }

            // --- SYNC LOSS (åŒæœŸã‚ºãƒ¬) ---
            if (syncAmount > 0) {
                const maxShift = Math.floor(width * (syncAmount / 80)); // æœ€å¤§ã‚ºãƒ¬å¹…ã‚’å¤§ãã
                const numLinesToShift = Math.floor(height * (syncAmount / 200)); // ã‚ºãƒ©ã™è¡Œæ•°ã‚’å¢—ã‚„ã™

                for(let k = 0; k < numLinesToShift; k++) {
                    const y = Math.floor(Math.random() * height); // ã‚ºãƒ©ã™è¡Œã‚’ãƒ©ãƒ³ãƒ€ãƒ ã«é¸ã¶
                    const shift = Math.floor(Math.random() * maxShift) * 4; // ã‚ºãƒ¬é‡ (ãƒ”ã‚¯ã‚»ãƒ«)
                    if (shift > 0) {
                        const lineOffset = y * width * 4;
                        const lineBuffer = new Uint8ClampedArray(data.slice(lineOffset, lineOffset + width * 4)); // sliceã§ã¯ãªãUint8ClampedArrayã§ã‚³ãƒ”ãƒ¼ã‚’æœ€é©åŒ–
                        for (let x = 0; x < width * 4; x++) {
                            data[lineOffset + x] = lineBuffer[(x + shift) % (width * 4)];
                        }
                    }
                }
            }

            // --- COLOR BLEED (è‰²ã‚ºãƒ¬) ---
            if (colorAmount > 0) {
                const shiftAmount = Math.floor(colorAmount / 5); // ã‚ºãƒ©ã™é‡ (1-20ãƒ”ã‚¯ã‚»ãƒ«)
                
                for (let i = 0; i < data.length; i += 4) {
                    const rIndex = (i + shiftAmount * 4) % data.length;
                    let bIndex = (i - shiftAmount * 4);
                    if (bIndex < 0) bIndex = data.length + bIndex;
                    
                    data[i] = data[rIndex]; // Red
                    data[i + 2] = data[bIndex + 2]; // Blue
                }
            }

            // --- STATIC NOISE (ç ‚åµãƒã‚¤ã‚º) --- æ–°è¦ã‚¨ãƒ•ã‚§ã‚¯ãƒˆ
            if (noiseAmount > 0) {
                const noiseDensity = noiseAmount / 100; // 0-1ã®å¯†åº¦
                for (let i = 0; i < data.length; i += 4) {
                    if (Math.random() < noiseDensity) {
                        const gray = Math.floor(Math.random() * 255);
                        data[i] = gray;     // R
                        data[i + 1] = gray; // G
                        data[i + 2] = gray; // B
                        // data[i + 3] = 255; // A (é€æ˜åº¦) ã¯ãã®ã¾ã¾ã‹ã€ãƒã‚¤ã‚ºã«åˆã‚ã›ã¦èª¿æ•´
                    }
                }
            }
        }

        // åˆæœŸæç”»ãƒ«ãƒ¼ãƒ—ã®é–‹å§‹ (ã‚½ãƒ¼ã‚¹ãŒä½•ã‚‚ãªãã¦ã‚‚Canvasã®æ›´æ–°ã¯è¡Œã†)
        // ã“ã‚Œã«ã‚ˆã‚Šã€å¾Œã‹ã‚‰ã‚½ãƒ¼ã‚¹ãŒè¿½åŠ ã•ã‚ŒãŸéš›ã«ã‚¹ãƒ ãƒ¼ã‚ºã«é–‹å§‹ã§ãã‚‹
        if (!animationFrameId) {
            animationFrameId = requestAnimationFrame(processFrame);
        }
    </script>

</body>
</html>
